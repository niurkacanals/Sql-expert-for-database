package sqlite3

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// AuthorBookResult is the result of a search.
type AuthorBookResult struct {
	AuthorID   sql.NullInt64  `json:"author_id"`   // author_id
	AuthorName sql.NullString `json:"author_name"` // author_name
	BookID     sql.NullInt64  `json:"book_id"`     // book_id
	BookISBN   sql.NullString `json:"book_isbn"`   // book_isbn
	BookTitle  sql.NullString `json:"book_title"`  // book_title
	BookTags   sql.NullString `json:"book_tags"`   // book_tags
}

// AuthorBookResultsByTag runs a custom query, returning results as AuthorBookResult.
func AuthorBookResultsByTag(ctx context.Context, db DB, tag string) ([]*AuthorBookResult, error) {
	// query
	const sqlstr = `SELECT ` +
		`a.author_id, ` +
		`a.name AS author_name, ` +
		`b.book_id, ` +
		`b.isbn AS book_isbn, ` +
		`b.title AS book_title, ` +
		`b.tags AS book_tags ` +
		`FROM books b ` +
		`JOIN authors a ON a.author_id = b.author_id ` +
		`WHERE b.tags LIKE '%' || $1 || '%'`
	// run
	logf(sqlstr, tag)
	rows, err := db.QueryContext(ctx, sqlstr, tag)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*AuthorBookResult
	for rows.Next() {
		var abr AuthorBookResult
		// scan
		if err := rows.Scan(&abr.AuthorID, &abr.AuthorName, &abr.BookID, &abr.BookISBN, &abr.BookTitle, &abr.BookTags); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &abr)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
