package postgres

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// AuthorBookResult is the result of a search.
type AuthorBookResult struct {
	AuthorID   sql.NullInt64    `json:"author_id"`   // author_id
	AuthorName sql.NullString   `json:"author_name"` // author_name
	BookID     sql.NullInt64    `json:"book_id"`     // book_id
	BookISBN   sql.NullString   `json:"book_isbn"`   // book_isbn
	BookTitle  sql.NullString   `json:"book_title"`  // book_title
	BookTags   []sql.NullString `json:"book_tags"`   // book_tags
}

// AuthorBookResultsByTags runs a custom query, returning results as AuthorBookResult.
func AuthorBookResultsByTags(ctx context.Context, db DB, tags StringSlice) ([]*AuthorBookResult, error) {
	// query
	const sqlstr = `SELECT ` +
		`a.author_id, ` + // ::integer AS author_id
		`a.name, ` + // ::text AS author_name
		`b.book_id, ` + // ::integer AS book_id
		`b.isbn, ` + // ::text AS book_isbn
		`b.title, ` + // ::text AS book_title
		`b.tags::text[] AS book_tags ` +
		`FROM books b ` +
		`JOIN authors a ON a.author_id = b.author_id ` +
		`WHERE b.tags && $1::varchar[]`
	// run
	logf(sqlstr, tags)
	rows, err := db.QueryContext(ctx, sqlstr, tags)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*AuthorBookResult
	for rows.Next() {
		var abr AuthorBookResult
		// scan
		if err := rows.Scan(&abr.AuthorID, &abr.AuthorName, &abr.BookID, &abr.BookISBN, &abr.BookTitle, &abr.BookTags); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &abr)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
