// Package models contains the types for schema 'public'.
package models

// GENERATED BY XO. DO NOT EDIT.

// Proc represents a stored procedure.
type Proc struct {
	ProcName       string // proc_name
	ParameterTypes string // parameter_types
	ReturnType     string // return_type
	Comment        string // comment
}

// PgProcsBySchema runs a custom query, returning results as Proc.
func PgProcsBySchema(db XODB, schema string) ([]*Proc, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`p.proname, ` + // ::varchar AS proc_name
		`oidvectortypes(p.proargtypes), ` + // ::varchar AS parameter_types
		`pg_get_function_result(p.oid), ` + // ::varchar AS return_type
		`'' ` + // ::varchar AS comment
		`FROM pg_proc p ` +
		`INNER JOIN pg_namespace n ON p.pronamespace = n.oid ` +
		`WHERE n.nspname = $1 ` +
		`ORDER BY p.proname`

	// run query
	XOLog(sqlstr, schema)
	q, err := db.Query(sqlstr, schema)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Proc{}
	for q.Next() {
		p := Proc{}

		// scan
		err = q.Scan(&p.ProcName, &p.ParameterTypes, &p.ReturnType, &p.Comment)
		if err != nil {
			return nil, err
		}

		res = append(res, &p)
	}

	return res, nil
}

// MyProcsBySchema runs a custom query, returning results as Proc.
func MyProcsBySchema(db XODB, schema string) ([]*Proc, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`r.routine_name AS proc_name, ` +
		`(SELECT GROUP_CONCAT(l.dtd_identifier SEPARATOR ', ') ` +
		`FROM information_schema.parameters l ` +
		`WHERE l.specific_schema = r.routine_schema AND l.specific_name = r.routine_name AND l.ordinal_position > 0 ` +
		`ORDER BY l.ordinal_position) AS parameter_types, ` +
		`p.dtd_identifier AS return_type ` +
		`FROM information_schema.routines r ` +
		`INNER JOIN information_schema.parameters p ON ` +
		`p.specific_schema = r.routine_schema AND p.specific_name = r.routine_name AND p.ordinal_position = 0 ` +
		`WHERE r.routine_schema = ? ` +
		`ORDER BY r.specific_name`

	// run query
	XOLog(sqlstr, schema)
	q, err := db.Query(sqlstr, schema)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Proc{}
	for q.Next() {
		p := Proc{}

		// scan
		err = q.Scan(&p.ProcName, &p.ParameterTypes, &p.ReturnType)
		if err != nil {
			return nil, err
		}

		res = append(res, &p)
	}

	return res, nil
}
