package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// ProcParam is a stored procedure param.
type ProcParam struct {
	ParamName string `json:"param_name"` // param_name
	ParamType string `json:"param_type"` // param_type
}

// PostgresProcParams runs a custom query, returning results as ProcParam.
func PostgresProcParams(ctx context.Context, db DB, schema, proc string) ([]*ProcParam, error) {
	// query
	const sqlstr = `SELECT ` +
		`LEFT( ` +
		`PG_GET_FUNCTION_IDENTITY_ARGUMENTS(p.oid), ` +
		`-LENGTH(UNNEST(STRING_TO_ARRAY(OIDVECTORTYPES(p.proargtypes), ', '))) - 1 ` +
		`), ` + // ::varchar AS param_name
		`UNNEST(STRING_TO_ARRAY(OIDVECTORTYPES(p.proargtypes), ', ')) ` + // ::varchar AS param_type
		`FROM pg_proc p ` +
		`JOIN ONLY pg_namespace n ON p.pronamespace = n.oid ` +
		`WHERE n.nspname = $1 ` +
		`AND p.proname = $2`
	// run
	logf(sqlstr, schema, proc)
	rows, err := db.QueryContext(ctx, sqlstr, schema, proc)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*ProcParam
	for rows.Next() {
		var pp ProcParam
		// scan
		if err := rows.Scan(&pp.ParamName, &pp.ParamType); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pp)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// MysqlProcParams runs a custom query, returning results as ProcParam.
func MysqlProcParams(ctx context.Context, db DB, schema, proc string) ([]*ProcParam, error) {
	// query
	const sqlstr = `SELECT ` +
		`parameter_name AS param_name, ` +
		`dtd_identifier AS param_type ` +
		`FROM information_schema.parameters ` +
		`WHERE ordinal_position > 0 ` +
		`AND specific_schema = ? ` +
		`AND specific_name = ? ` +
		`ORDER BY ordinal_position`
	// run
	logf(sqlstr, schema, proc)
	rows, err := db.QueryContext(ctx, sqlstr, schema, proc)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*ProcParam
	for rows.Next() {
		var pp ProcParam
		// scan
		if err := rows.Scan(&pp.ParamName, &pp.ParamType); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pp)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// SqlserverProcParams runs a custom query, returning results as ProcParam.
func SqlserverProcParams(ctx context.Context, db DB, schema, proc string) ([]*ProcParam, error) {
	// query
	const sqlstr = `SELECT ` +
		`SUBSTRING(p.name, 2, LEN(p.name)-1) AS param_name, ` +
		`TYPE_NAME(p.user_type_id) AS param_type ` +
		`FROM sys.objects o ` +
		`INNER JOIN sys.parameters p ON o.object_id = p.object_id ` +
		`WHERE SCHEMA_NAME(schema_id) = @p1 ` +
		`AND o.name = @p2 ` +
		`AND p.is_output = 'false' ` +
		`ORDER BY p.parameter_id`
	// run
	logf(sqlstr, schema, proc)
	rows, err := db.QueryContext(ctx, sqlstr, schema, proc)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*ProcParam
	for rows.Next() {
		var pp ProcParam
		// scan
		if err := rows.Scan(&pp.ParamName, &pp.ParamType); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pp)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
