package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// ProcParam represents a stored procedure param.
type ProcParam struct {
	ParamType string `json:"param_type"` // param_type
}

// PostgresProcParams runs a custom query, returning results as ProcParam.
func PostgresProcParams(ctx context.Context, db DB, schema, proc string) ([]*ProcParam, error) {
	// query
	const sqlstr = `SELECT ` +
		`UNNEST(STRING_TO_ARRAY(oidvectortypes(p.proargtypes), ', ')) ` + // ::varchar AS param_type
		`FROM pg_proc p ` +
		`JOIN ONLY pg_namespace n ON p.pronamespace = n.oid ` +
		`WHERE n.nspname = $1 AND p.proname = $2`
	// run
	logf(sqlstr, schema, proc)
	rows, err := db.QueryContext(ctx, sqlstr, schema, proc)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*ProcParam
	for rows.Next() {
		var pp ProcParam
		// scan
		if err := rows.Scan(&pp.ParamType); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pp)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// MysqlProcParams runs a custom query, returning results as ProcParam.
func MysqlProcParams(ctx context.Context, db DB, schema, proc string) ([]*ProcParam, error) {
	// query
	const sqlstr = `SELECT ` +
		`dtd_identifier AS param_type ` +
		`FROM information_schema.parameters ` +
		`WHERE ordinal_position > 0 AND specific_schema = ? AND specific_name = ? ` +
		`ORDER BY ordinal_position`
	// run
	logf(sqlstr, schema, proc)
	rows, err := db.QueryContext(ctx, sqlstr, schema, proc)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*ProcParam
	for rows.Next() {
		var pp ProcParam
		// scan
		if err := rows.Scan(&pp.ParamType); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pp)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
